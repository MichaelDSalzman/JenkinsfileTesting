def envName = "Sandbox"
def envLanguage = "en"

def jiraIssueId

def slackLib
def sonarLib 
def messageBuilderLib

boolean sendGenericFailureMsg = true
String slackMessage = env.slack_message_unexpected_failure

pipeline{
    agent any //TODO Waiting on Ops to create an appropriate worker.
  
    stages{
        stage("Init") {
            steps{
                echo "========Running init========"
                script {
                    load("ci/helpers/envLoader.groovy").load(envName, envLanguage)

                    slackLib = load "ci/helpers/slack.groovy"
                    sonarLib = load "ci/helpers/sonar.groovy"
                    messageBuilderLib = load "ci/helpers/message_builders.groovy"

                    def jiraIssueIdMatcher = (env.GIT_BRANCH =~ /^(AF-\d+)-.*$/)​​
                    if (jiraIssueIdMatcher.matches()) {
                        jiraIssueId = jiraIssueIdMatcher[0]​[1]
                    } else {
                        error "NO JIRA ISSUE ID COULD BE FOUND IN THE BRANCH NAME"
                    }
                }
            }
        }
        stage("testing jira comment") {
            steps{
                script {
                    withEnv(['JIRA_SITE=EC2']) {
                        def comment = [body: 'My comment for this ticket']
                        jiraAddComment idOrKey: jiraIssueId, input: comment
                    }
                }
            }
        }
        stage("Install dependencies"){
            steps{
                echo "========Installing dependencies========"
                sh "npm install -g yarn"
                sh "yarn install"
            }
            post{
                failure{
                    script{
                        slackMessage = env.slack_message_dependency_installation_failure
                    }
                }
            }
        }
        stage("NexusIQ Scan"){
            steps{
                echo "========executing NexusIQ scan========"
            }
            post{
                failure{
                    script{
                        slackMessage = env.slack_message_nexus_scan_failure
                    }
                }
            }
        }
        stage("Unit && e2e Tests w/o coverage"){
            steps{
                echo "========executing unit && e2e tests w/o coverage========"
                // sh 'yarn test:unit'     
            }
            post{
                failure{
                    script{
                        slackMessage = env.slack_message_tests_failure
                    }
                }
            }
        }
        stage("Unit && e2e Tests w/coverage"){
            steps{
                echo "========executing unit && e2e tests w/coverage========"
                // script {
                //     def testResult = sh(script: "yarn test:unit", returnStatus: true)
                //     if (testResult != 0) {
                //         currentBuild.result = 'UNSTABLE'
                //         slackMessage = env.slack_message_test_coverage_failure
                //     }
                // }             
            }
        }
        stage("SonarQube scan"){
            steps{
                echo "========executing SonarQube scan========"
                script {
                    sonarLib.scan({Map sonarResult ->
                        slackLib.sendDetailedMessage(
                            messageBuilderLib.generateSonarFailureDetailedSlackMessage(sonarResult.failedConditions, sonarResult.dashboardUrl)
                        )
                            
                        sendGenericFailureMsg = false
                        error "Sonar Quality scan failed"
                    })
                }
            }
            post{
                failure{
                    script{
                        slackMessage = env.slack_message_sonar_failure
                    }
                }
            }
        }
        stage("Package"){
            steps{
                echo "========Packaging========"
            }
            post{
                failure{
                    script{
                        slackMessage = env.slack_message_packaging_failure
                    }
                }
            }
        }
    }
    post{
        always{
            echo "========always========"
        }
        success{
            echo "========pipeline executed successfully ========"
            script {
                currentBuild.result != 'UNSTABLE'
                    ? slackLib.success(env.slack_message_generic_success)
                    : slackLib.warning(slackMessage)
            }
        }
        failure{
            echo "========pipeline execution failed========"
            script {
                if(sendGenericFailureMsg) {
                    slackLib.failure(slackMessage)
                }
            }            
        }
    }
}